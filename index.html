<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Skor-Heroes | Eliav Skornick Precise Edition</title>
    
    <!-- Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Luckiest+Guy&family=Rubik:wght@400;900&display=swap');

        :root {
            --primary: #00f2ff;
            --secondary: #ff007a;
            --gold: #ffcc00;
            --bg: #010105;
            --danger: #ff0000;
        }

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background-color: var(--bg); color: white;
            font-family: 'Rubik', sans-serif; overflow: hidden;
            user-select: none; touch-action: none;
        }

        /* Fullscreen Ghost Camera */
        #webcam-view {
            position: fixed; inset: 0; width: 100vw; height: 100vh;
            z-index: 0; transform: scaleX(-1); opacity: 0.04;
            pointer-events: none; filter: brightness(0.5) contrast(1.2);
        }
        video { width: 100%; height: 100%; object-fit: cover; }

        #canvas-container { position: absolute; inset: 0; z-index: 2; background: transparent; }

        /* Game UI */
        .game-ui {
            position: absolute; inset: 0; z-index: 10;
            pointer-events: none; padding: env(safe-area-inset-top, 20px) 20px 20px 20px;
            display: flex; flex-direction: column;
        }

        .top-row { display: flex; justify-content: space-between; align-items: center; width: 100%; }
        
        .score-box {
            background: rgba(0,0,0,0.9); border: 2.5px solid var(--primary);
            padding: 8px 18px; border-radius: 50px;
            font-family: 'Luckiest Guy', cursive; font-size: 1.5rem;
            box-shadow: 0 0 15px var(--primary);
        }

        .timer-container {
            position: relative; width: 65px; height: 65px;
            display: flex; align-items: center; justify-content: center;
        }
        .timer-svg { transform: rotate(-90deg); width: 65px; height: 65px; }
        .timer-bg { fill: none; stroke: rgba(255,255,255,0.05); stroke-width: 8; }
        .timer-bar { 
            fill: none; stroke: var(--secondary); stroke-width: 8; 
            stroke-dasharray: 188; stroke-dashoffset: 0;
            transition: stroke-dashoffset 0.1s linear;
        }
        #timer-text { position: absolute; font-family: 'Luckiest Guy'; font-size: 1.5rem; color: #fff; }

        .mission-header { width: 100%; text-align: center; margin-top: 10px; }
        #level-tag { font-family: 'Luckiest Guy'; color: var(--gold); font-size: 1.8rem; text-shadow: 0 0 10px rgba(255,204,0,0.5); }
        #mission-text { font-size: 0.85rem; font-weight: 900; color: var(--danger); text-transform: uppercase; letter-spacing: 1px; }

        /* Overlay Screens */
        .overlay-screen {
            position: fixed; inset: 0; background: rgba(0, 0, 0, 0.98);
            z-index: 1000; display: flex; flex-direction: column;
            align-items: center; justify-content: center; text-align: center; padding: 30px;
        }
        .game-title { font-family: 'Luckiest Guy'; font-size: clamp(3rem, 15vw, 6rem); color: var(--primary); margin: 0; }
        .by-text { font-family: 'Rubik'; font-weight: 900; color: var(--gold); margin-top: 5px; font-size: 1.2rem; letter-spacing: 3px; }
        
        .play-btn {
            background: var(--gold); color: #000; border: none;
            padding: 15px 45px; font-size: 2rem; font-family: 'Luckiest Guy';
            border-radius: 20px; cursor: pointer; margin-top: 30px;
            box-shadow: 0 10px 0 #b38f00; pointer-events: auto;
        }
        .play-btn:active { transform: translateY(5px); box-shadow: 0 5px 0 #b38f00; }

        .fail-msg { color: var(--danger); font-size: 1.5rem; font-weight: 900; margin-top: 10px; }

        .floating-text { position: fixed; font-family: 'Luckiest Guy'; pointer-events: none; z-index: 50; }
    </style>
</head>
<body>

    <!-- Start Screen -->
    <div id="boot-screen" class="overlay-screen">
        <h1 class="game-title">SKOR-HEROES</h1>
        <p class="by-text">BY ELIAV SKORNICK</p>
        <div style="margin-top: 25px; color: #fff; font-weight: bold;">5s SPEED RUN â€¢ PRECISION HITBOXES</div>
        <button class="play-btn" onclick="startGame()">START</button>
    </div>

    <!-- Final Victory Screen -->
    <div id="victory-screen" class="overlay-screen" style="display: none;">
        <h1 class="game-title" style="color: var(--gold);">TRUE LEGEND</h1>
        <p style="font-size: 1.5rem; margin: 20px 0;">You conquered all 50 levels!</p>
        <p style="font-family: 'Luckiest Guy'; color: var(--gold); font-size: 1.8rem;">GOLDEN SKIN UNLOCKED</p>
        <button class="play-btn" onclick="enterGodMode()">GOD MODE</button>
    </div>

    <!-- Fail Screen -->
    <div id="fail-screen" class="overlay-screen" style="display: none;">
        <h1 class="game-title" style="color: var(--danger);">TERMINATED</h1>
        <p id="fail-reason" class="fail-msg">TIME EXPIRED</p>
        <p style="opacity: 0.6; margin-top: 20px;">Hardcore Reset: Returning to Level 1</p>
        <button class="play-btn" onclick="restartFromStart()">REBOOT</button>
    </div>

    <div id="webcam-view"><video id="webcam" autoplay playsinline></video></div>
    <div id="canvas-container"></div>

    <div class="game-ui">
        <div class="top-row">
            <div class="score-box" id="score-display">0000</div>
            <div class="timer-container">
                <svg class="timer-svg">
                    <circle class="timer-bg" cx="32.5" cy="32.5" r="30"></circle>
                    <circle id="timer-bar" class="timer-bar" cx="32.5" cy="32.5" r="30"></circle>
                </svg>
                <div id="timer-text">5</div>
            </div>
        </div>
        <div class="mission-header">
            <div id="level-tag">LEVEL 1</div>
            <div id="mission-text">FOCUS ON TARGETS</div>
        </div>
    </div>

    <script>
        let scene, camera, renderer, clock;
        let handCursor, handTarget = new THREE.Vector3();
        let targets = [], obstacles = [];
        let isPinching = false, godMode = false, isLegend = false;
        let safeBounds = { x: 50, y: 50 };
        
        let gameState = {
            level: 1, score: 0, active: false, timeLeft: 5
        };

        function updateSafeBounds() {
            if (!camera) return;
            const aspect = window.innerWidth / window.innerHeight;
            const vFOV = THREE.MathUtils.degToRad(camera.fov);
            const height = 2 * Math.tan(vFOV / 2) * camera.position.z;
            const width = height * aspect;
            safeBounds.x = (width / 2) * 0.75;
            safeBounds.y = (height / 2) * 0.75;
        }

        function getGeometry(lvl, idx) {
            const types = [
                () => new THREE.IcosahedronGeometry(18, 0),
                () => new THREE.BoxGeometry(20, 20, 20),
                () => new THREE.TorusGeometry(14, 5, 12, 24),
                () => new THREE.OctahedronGeometry(18, 0),
                () => new THREE.DodecahedronGeometry(16, 0)
            ];
            return types[(lvl + idx) % types.length]();
        }

        function getLevelConfig(lvl) {
            const isBoss = lvl % 5 === 0;
            const items = isBoss ? 1 : Math.min(4 + Math.floor(lvl / 1.6), 30);
            const speed = 0.25 + (lvl * 0.12);
            const mines = lvl < 4 ? 0 : Math.min(Math.floor(lvl / 3), 12);
            return {
                title: isBoss ? `BOSS FIGHT ${lvl/5}` : `WORLD ${Math.ceil(lvl/10)}-${lvl%10||10}`,
                task: lvl % 2 === 0 ? "WATCH THE MINES!" : "STAY FAST!",
                color: new THREE.Color().setHSL((lvl * 0.13) % 1, 0.8, 0.5),
                items, speed, mines, isBoss
            };
        }

        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
            camera.position.z = 250;
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const pLight = new THREE.PointLight(0x00f2ff, 2.5, 1000);
            pLight.position.set(0, 100, 200);
            scene.add(pLight);
            handCursor = new THREE.Mesh(
                new THREE.TorusGeometry(14, 2, 16, 32),
                new THREE.MeshBasicMaterial({ color: 0x00f2ff, transparent: true, opacity: 0.8 })
            );
            scene.add(handCursor);
            updateSafeBounds();
            clock = new THREE.Clock();
            animate();
        }

        async function startGame() {
            document.getElementById('boot-screen').style.display = 'none';
            if(!scene) initThree();
            const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5 });
            hands.onResults(onHandResults);
            const video = document.getElementById('webcam');
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } });
            video.srcObject = stream;
            new Camera(video, { onFrame: async () => await hands.send({image: video}), width: 640, height: 480 }).start();
            setupLevel();
        }

        function onHandResults(res) {
            if (!gameState.active || !res.multiHandLandmarks) return;
            const lm = res.multiHandLandmarks[0];
            if(lm) {
                handTarget.x = (0.5 - lm[8].x) * (safeBounds.x * 2.7); 
                handTarget.y = (0.5 - lm[8].y) * (safeBounds.y * 2.7);
                const thumb = lm[4];
                const dist = Math.sqrt(Math.pow(lm[8].x-thumb.x, 2) + Math.pow(lm[8].y-thumb.y, 2));
                if(dist < 0.08) { if(!isPinching) checkCollision(); isPinching = true; } else isPinching = false;
            }
        }

        function spawnEntities(c) {
            targets.concat(obstacles).forEach(e => scene.remove(e));
            targets = []; obstacles = [];
            for(let i=0; i<c.items; i++) {
                const geo = c.isBoss ? new THREE.TorusKnotGeometry(35, 12, 100, 16) : getGeometry(gameState.level, i);
                const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: c.color, emissive: c.color, emissiveIntensity: 0.5 }));
                mesh.position.set((Math.random()-0.5)*safeBounds.x*1.8, (Math.random()-0.5)*safeBounds.y*1.8, 0);
                mesh.userData = { vel: new THREE.Vector3((Math.random()-0.5)*c.speed, (Math.random()-0.5)*c.speed, 0) };
                scene.add(mesh); targets.push(mesh);
            }
            if(!godMode) {
                for(let i=0; i<c.mines; i++) {
                    const mesh = new THREE.Mesh(new THREE.OctahedronGeometry(15, 0), new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000 }));
                    mesh.position.set((Math.random()-0.5)*safeBounds.x*1.8, (Math.random()-0.5)*safeBounds.y*1.8, 0);
                    // Ensure mine isn't right on top of cursor start
                    if(mesh.position.distanceTo(handCursor.position) < 80) mesh.position.x += 100;
                    mesh.userData = { vel: new THREE.Vector3((Math.random()-0.5)*c.speed*1.3, (Math.random()-0.5)*c.speed*1.3, 0), mine: true };
                    scene.add(mesh); obstacles.push(mesh);
                }
            }
        }

        function setupLevel() {
            updateSafeBounds();
            const c = getLevelConfig(gameState.level);
            gameState.timeLeft = 5;
            gameState.active = true;
            document.getElementById('level-tag').innerText = c.title;
            document.getElementById('mission-text').innerText = c.task;
            spawnEntities(c);
        }

        function checkCollision() {
            // Precise target radius: 50
            targets.forEach((t, i) => {
                if(t.position.distanceTo(handCursor.position) < 50) {
                    targets.splice(i, 1); scene.remove(t);
                    gameState.score += 150;
                    if(targets.length === 0) {
                        if(gameState.level === 50) triggerUltimateVictory();
                        else nextLevel();
                    }
                }
            });
            // TIGHT mine radius: 22 (Used to be 40!)
            obstacles.forEach(o => {
                if(o.position.distanceTo(handCursor.position) < 22) {
                    triggerFail("MINE DETONATED!");
                }
            });
        }

        function triggerUltimateVictory() {
            gameState.active = false; isLegend = true;
            handCursor.material.color.setHex(0xffcc00);
            confetti({ particleCount: 200, spread: 90, origin: { y: 0.6 } });
            document.getElementById('victory-screen').style.display = 'flex';
        }

        function triggerFail(reason) {
            if(godMode) return;
            gameState.active = false;
            document.getElementById('fail-reason').innerText = reason;
            document.getElementById('fail-screen').style.display = 'flex';
        }

        function restartFromStart() {
            gameState.level = 1; gameState.score = 0;
            document.getElementById('fail-screen').style.display = 'none';
            setupLevel();
        }

        function nextLevel() {
            gameState.level++;
            setupLevel();
        }

        function enterGodMode() {
            godMode = true; document.getElementById('victory-screen').style.display = 'none';
            gameState.level = 1; setupLevel();
        }

        function animate() {
            requestAnimationFrame(animate);
            if(gameState.active && !godMode) {
                gameState.timeLeft -= 1/60;
                const perc = gameState.timeLeft / 5;
                document.getElementById('timer-bar').style.strokeDashoffset = 188 * (1 - perc);
                document.getElementById('timer-text').innerText = Math.max(0, Math.ceil(gameState.timeLeft));
                if(gameState.timeLeft <= 0) triggerFail("TIME EXPIRED!");
            }
            if(handCursor) {
                handCursor.position.lerp(handTarget, 0.25);
                handCursor.rotation.z += 0.08;
                if(isLegend) handCursor.scale.setScalar(1.5 + Math.sin(Date.now()*0.01)*0.2);
            }
            [...targets, ...obstacles].forEach(e => {
                e.position.add(e.userData.vel);
                if(Math.abs(e.position.x) > safeBounds.x) e.userData.vel.x *= -1;
                if(Math.abs(e.position.y) > safeBounds.y) e.userData.vel.y *= -1;
                e.rotation.x += 0.03; e.rotation.y += 0.03;
            });
            renderer.render(scene, camera);
            document.getElementById('score-display').innerText = gameState.score.toString().padStart(4, '0');
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateSafeBounds();
        });
    </script>
</body>
</html>

